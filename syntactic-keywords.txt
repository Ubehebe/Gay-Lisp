Syntactic keywords in R5RS Scheme
Brendan Linn
26 January 2012

At the very beginning of the "Basic concepts" section, the standard R5RS
 states (3.1):

1. "An identifier may name a type of syntax, or it may name a location
where a value can be stored."

I interpret this to mean that every bound identifier either names
a type of syntax or it names a location where a value can be stored.

The standard further states (4.3):

2. "The syntactic keyword of a macro may shadow variable bindings,
and local variable bindings may shadow keyword bindings."

On a casual read, this seems to state that any identifier that occurs
in a program text can name different types of things each time it
occurs.

However, the modifier "of a macro" is important. Not all syntactic
keywords are syntactic keywords of a macro. Here are the relevant
rules from the lexical grammar (7.1.1):

3. <syntactic keyword> -> <expression keyword> | else | => | define |
unquote | unquote-splicing

4. <expression keyword> -> quote | lambda | if | set! | begin | cond |
 and | or | case | let | let* | letrec | do | delay | quasiquote

Unfortunately, these rules seem incomplete in two ways. First, they do
not include the identifiers

5. define-syntax, let-syntax, letrec-syntax, syntax-rules

even though all of these are listed as "syntax" in section 4, and none
of them is given a macro implementation. This is mysterious to
me. Second, the set of identifiers that count as syntactic
keywords is presented in 3-4 as closed, but elsewhere, the standard
suggests this set can be added to during the execution of a
program. For example, the standard states (4.3):

6. "Program-defined expression types have the syntax
(<keyword> <datum> ...), where <keyword> is an identifier that
uniquely determines the expression type. This identifier is called the
syntactic keyword, or simply keyword, of the macro."

Section 7.3 gives macro implementations for the following syntactic
keywords:

7. else, =>, cond, and, or, case, let, let*, letrec, do, delay.

That leaves the following as syntactic keywords (as listed in 3-5)
that have no macro implementation:

8. begin, define, define-syntax, if, lambda, let-syntax,
 letrec-syntax, quasiquote, quote, set!, unquote, unquote-splicing.

(begin is given a partial macro implementation in section 7.3 that is
applicable in only some contexts, so I include it in this list.) In
this document, I will call the members of 8 "builtin syntactic
keywords", even though there is no such concept in the standard.

Therefore, I think the appropriate interpretation of 2 is

9. Any identifier that is not a builtin syntactic keyword may shadow
variable bindings, and local variable bindings may shadow bindings of
any identifier that is not a builtin syntactic keyword.

Notice that this places no restrictions on the shadowing behavior of builtin
syntactic keywords. As far as I can tell, this issue is discussed in
two places. The more helpful is section 4.3.1. It contains a long
example that can be abbreviated for our purposes as:

10. (let ((let odd?) (if even?)) (or (let 8) (if 7))) => #f

This clearly shows shadowing of both builtin and non-builtin syntactic
keywords (if and let respectively). Let's dig in to the macro
transcription to see what happens. The input in 10 is matched
successfully against the pattern

11. (let ((name val) ...) body1 body2 ...)

giving the bindings name = let, if, val = odd?, even?,
body1 = (or (let 8) (if 7)). ("Pattern variables match arbitrary input
elements", according to section 4.3.2, so matching syntactic keywords
is clearly okay.) This is then transcribed according to the template

12. ((lambda (name ...) body1 body2 ...) val ..)

giving the output

13. ((lambda (let if) (or (let 8) (if 7))) odd? even?)

TODO bl: "If a macro transformer inserts a binding for an identifier
(variable or keyword), the identifier will in effect be renamed
throughout its scope to avoid conflicts with other identifiers."

At this point, we have to make a decision about syntactic keywords and
variables. 9 clearly says that it is okay for a formal parameter to be
named "let". It does not say whether if can be a formal parameter.

Unfortunately, the grammar for <variable> is not helpful. It states
(7.1.1):

14. <variable> -> <any <identifier> that isn't also a <syntactic
keyword>>

There are several reasonable interpretations of <syntactic keyword> in
14, but in any such interpretation, let counts as a syntactic
keyword. Then 14 says that let cannot be a variable, which would seem
to contradict 9. So there is trouble regardless of what we decide to
do with the builtin syntactic keyword if.

At this point, I gave up trying to determine the intent of the
standard, turning to examine existing implementations instead. Both
PLT Scheme and MIT Scheme seem to allow any identifier as a
variable. For example, all of the following are legal in both
implementations:

15. (define x 1) ((lambda (lambda) (lambda x x)) +) => 2
16. (define x 1) ((lambda (define) (define x 2) x) +) => 1
17. ((lambda (if) (if #f 2 3)) (lambda xs (cadr xs))) => 2

For my implementation, I decided to allow syntactic keywords as
formal parameters, but silently rewrite them.

TODO bl: still need to examine things like (define if 2), which is
legal in both implementations, and (define x if), which isn't.
